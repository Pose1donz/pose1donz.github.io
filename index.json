[{"content":"写在前面 为了完成作业，用python做了一个简单的区块链实现和多线程矿工挖矿模拟。老师要求的是用txt文件来存储区块的信息，在进行类的txt存储时对自定义类的存储和读取做了简单的了解。\n实现要点 自定义类的存储的读取 引入python的pickle模块，它能够实现任意对象与文本之间的相互转化，也可以实现任意对象与二进制之间的相互转化。也就是说，pickle 可以实现 Python 对象的存储及恢复。\npickle主要用法\n读取：\nloads（）是反序列化，跟文件没关系\nwith open(\u0026#34;blockchain.txt\u0026#34;, \u0026#39;rb\u0026#39;) as f://必须用二进制来存储，否则会报错 try://读到不能读 while (1): datablock = pickle.load(f)//读取一个存储的模块 nowindex += 1 except: pass 写入：\nwith open(\u0026#34;blockchain.txt\u0026#34;, \u0026#39;ab\u0026#39;) as f: pickle.dump(block,f)//写入一个 dumps（）是序列化但不写入\nps：元组，字典也可以利用pickle序列化，其实类的序列号也是类似字典的形式存储，在文件中有一个结束符，所以每次load都会读取一个被序列化了的对象，把它重新转化为字典的形式。\n其次，pickle目前是不安全的，要谨慎使用，具体请google或参考下面的链接\n从零开始python反序列化攻击：pickle原理解析 \u0026amp; 不用reduce的RCE姿势 - 知乎 (zhihu.com)\n区块链的实现 这一部分就不在这里嗦了，以后可能会单独写一篇~\npython的多线程 Python其实是没有真正的多线程的！\n为什么这么说，我们先明确一个概念，全局解释器锁（GIL）。 Python代码的执行由Python虚拟机（解释器）来控制。Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。 同样地，虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。\n在多线程环境中，Python虚拟机按照以下方式执行。\n1.设置GIL。\n2.切换到一个线程去执行。\n3.运行。\n4.把线程设置为睡眠状态。\n5.解锁GIL。\n6.再次重复以上步骤。\nPython不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。看起来很不可思议？但是这就是GIL搞的鬼。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁， 让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。\n所以在python中如果你想要好好的利用多核优势，你可以用c语言链接库编写程序，然后将.so链接库内容加载到python中。或者同时跑多个python程序，因为每个python程序都有自己的GIL锁（多进程）\n线程 import threading//引入模块 MUTEXALL = threading.Lock()//全局变量实例锁 MUTEXALL.acquire()//上锁 MUTEXALL.release()//下锁 源码 import hashlib # hash 算法 from time import time # 时间戳 import pickle import threading VERSION=\u0026#34;1.0\u0026#34; LEVEL=pow(2,256)-pow(2,244) MUTEXALL = threading.Lock() MAXBLOCKNUM=10 class Block:#没有实现Merkel根,因为灭有存储交易信息 \u0026#34;\u0026#34;\u0026#34;创建了一个block类\u0026#34;\u0026#34;\u0026#34; def __init__(self,index,data,prehash,nouce): \u0026#34;\u0026#34;\u0026#34;初始化块的属性index，data，prehash，level，version，timeunix，nouce\u0026#34;\u0026#34;\u0026#34; self.index=index self.data=data self.prehash=prehash self.level=LEVEL self.version=VERSION self.timeunix=int(time()) self.nouce=nouce def calhash(self): \u0026#34;\u0026#34;\u0026#34;计算该区块的哈希值\u0026#34;\u0026#34;\u0026#34; sec = hashlib.sha256() data = str(self.index)+str(self.data)+str(self.prehash)+str(self.level)+str(self.version)+str(self.timeunix)+str(self.nouce) sec.update(data.encode(\u0026#34;utf-8\u0026#34;)) return sec.hexdigest() def testify(self): \u0026#34;\u0026#34;\u0026#34;验证该区块的哈希是否满足现在的难度目标值\u0026#34;\u0026#34;\u0026#34; return int(self.calhash(),16)\u0026lt;LEVEL class Miner: \u0026#34;\u0026#34;\u0026#34;创建了一个矿工对象\u0026#34;\u0026#34;\u0026#34; def __init__(self,addr): self.addr=addr self.nowblockindex=0 def checkright(self): \u0026#34;\u0026#34;\u0026#34;挖矿检验是否正确程序，为了区别不同矿工，nouce的更新方式有些许不同\u0026#34;\u0026#34;\u0026#34; while 1: nowindex=0 MUTEXALL.acquire() with open(\u0026#34;blockchain.txt\u0026#34;, \u0026#39;rb\u0026#39;) as f: try: while (1): datablock = pickle.load(f) nowindex+=1 except: pass MUTEXALL.release() if nowindex\u0026lt;MAXBLOCKNUM: if nowindex!=self.nowblockindex: self.nowblockindex=nowindex self.nowblock=Block(self.nowblockindex,\u0026#34;Im the \u0026#34;+str(self.nowblockindex)+\u0026#34; block!\u0026#34;,datablock.calhash(),0) else: if self.nowblock.testify(): nowindex=0 MUTEXALL.acquire() with open(\u0026#34;blockchain.txt\u0026#34;, \u0026#39;rb\u0026#39;) as f: try: while (1): datablock = pickle.load(f) nowindex += 1 except: pass MUTEXALL.release() if nowindex==self.nowblockindex: MUTEXALL.acquire() writrblockchian(self.nowblock) MUTEXALL.release() print(\u0026#34;NEW BLOCK HAS BEEN CREATED BY MINER \u0026#34;+str(self.addr)+\u0026#34; AND THE BLOCK \u0026#34;+str(self.nowblock.index)+\u0026#34; HASH IS \u0026#34;+self.nowblock.calhash()) else: pass else: self.nowblock.nouce+=self.addr else: return 1 def writrblockchian(block): \u0026#34;\u0026#34;\u0026#34;在blockchian.txt中追加写入区块\u0026#34;\u0026#34;\u0026#34; with open(\u0026#34;blockchain.txt\u0026#34;, \u0026#39;ab\u0026#39;) as f: pickle.dump(block,f) def createthefoundationblock(): \u0026#34;\u0026#34;\u0026#34;创建创世区块\u0026#34;\u0026#34;\u0026#34; tfb=Block(0,\u0026#34;im the fa of the all block.\u0026#34;,2002077222020100225,20020722) writrblockchian(tfb) print(\u0026#34;NEW FOUNDATION BLOCK HAS BEEN CREATED AND THE BLOCK HASH IS \u0026#34; + tfb.calhash()) def showallblockintext(): \u0026#34;\u0026#34;\u0026#34;打印所有在blockchain.txt里的block\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;\\n\\n\u0026#34;) with open(\u0026#34;blockchain.txt\u0026#34;, \u0026#39;rb\u0026#39;) as f: try: while (1): datablock = pickle.load(f) print(\u0026#34;the block \u0026#34; + str(datablock.index) + \u0026#34; :\u0026#34;) print(\u0026#34; data: \u0026#34; + str(datablock.data)) print(\u0026#34; timeunix: \u0026#34; + str(datablock.timeunix)) print(\u0026#34; prehash: \u0026#34; + str(datablock.prehash)) print(\u0026#34; version: \u0026#34; + str(datablock.version)) print(\u0026#34; level: \u0026#34; + str(datablock.level)) print(\u0026#34; nouce: \u0026#34; + str(datablock.nouce)) print() except: pass createthefoundationblock() print(\u0026#34;NOW EVEVY MINER IS WORKING!\u0026#34;) miner1=Miner(1) miner2=Miner(2) miner3=Miner(3) the1=threading.Thread(target=miner1.checkright,args=()) the2=threading.Thread(target=miner2.checkright,args=()) the3=threading.Thread(target=miner3.checkright,args=()) the3.start() the2.start() the1.start() the2.join() the1.join() the3.join() showallblockintext() ","permalink":"https://pose1donz.github.io/posts/tech/%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%9E%E7%8E%B0/","summary":"写在前面 为了完成作业，用python做了一个简单的区块链实现和多线程矿工挖矿模拟。老师要求的是用txt文件来存储区块的信息，在进行类的txt存储时对自定义类的存储和读取做了简单的了解。 实现要点 自定义类的存储的读取 引入python的pickle模块，它能够实现任意对象与文本之间的相","title":"简单的区块链实现"},{"content":"​ 首先安装hugo框架 详见Content Organization - Hugo中文文档 (gohugo.org)\n​\t安装好hugo后你可以选择按照hugo的官方文档自己DIY网站的制作也可以再网上寻找别人已经制作好的hugo主题 笔者用的是第二种方法来构建自己的博客 主题链接为：[https://github.com/xyming108/sulv-hugo-papermod](https://github.com/adityatelange/hugo-PaperMod)\n1.git clone 拉取代码 ① 用git clone的方式拉取代码，此时会生成sulv-hugo-papermod目录\n② 进入到sulv-hugo-papermod目录，输入git submodule update --init，表示拉取themes/hugo-PaperMod/下的子模块，里面放的是官方主题\n2.启动界面 把目录定位到sulv-hugo-papermod下，在终端输入hugo server -D，在浏览器输入：localhost:1313 即可看到现成的博客模板。以此方式来对博客进行调试\n3.修改信息 因为是别人的主题 有很多信息需要自己来修改 但原博说的并不是很详细，自己也踩了很多坑，所以着重说说这一部分。\n首先说明一下各个文件及文件夹的大概作用。\n当你创建一个博客时，实际是通过hugo程序和当前文件夹里的文件共同作用来快速生成各个html文件并将它们链接起来的。\nconfig.yml影响了你整个博客的生成。其中记录了如作者，语言，个人信息等重要参数。着重讲一下其中的baseurl，其表示的是网站的相对路径，影响着你html文件中各种资源（如css，js，jpg）的链接。其值应该设置为你将要将其部署的域名。这也导致了当你并没有把文件上传到服务器上时，你进行hugo生成的public文件夹里的各个页面的载入错误。（所以你只需要保证baseurl正确然后利用hugo server -D来进行调试即可）\nthemes是你博客采用的子主题\nstatic里存放你的各种字体，视频，图片资源\nlayouts里是你生成各种页面的框架，即html文件\nasset里存放的是css和js文件\n其他的作用不大（其实是我还不太懂\u0026hellip;）\n5.上传到github上 首先要拥有一个自己的GitHub账号\n1.创建一个public仓库 名字为 你的用户名.github.io\n2.在本地在你的博客工作文件夹中 hugo 生成一个public文件夹，当我们把这个文件夹push到刚刚创建的仓库中就可以看到自己的博客啦\n3.安装git并了解一些git指令\n一些常用的git指令 首先要登陆你的github账号，可以采用ssh登录，方便快捷 百度\ngit init #在一个文件夹中初始化git环境\ngit remote add origin https://\u0026hellip;\u0026hellip;\u0026hellip; #远程连接，后面的地址为你的目的仓库\ngit remote -v #查看该文件夹远程连接状态\ngit add . #将现路径下的所有文件添加\ngit commit -m \u0026ldquo;msg\u0026rdquo; #提交\ngit push origin master #上传\ngit push origin master -f #强制上传，如果你很清楚你要做什么，就用这个\ngit pull origin master\ngit pull https://\u0026hellip;\u0026hellip;. #拉取文件，多人工作时要用到\n6.怎么写博客和更新网站 生成博客 hugo new 生成文件相对路径\nhugo new posts/tech/文章名称.md，这样就会把文章生成到tech目录下\nmd文件如果要拉取图片，可以在md文件同文件夹生成一个同名文件夹里面来存放该博客需要的图片，引用格式如下\n更新微博 先hugo重新生成public目录\n在用git命令上传即可\n","permalink":"https://pose1donz.github.io/posts/blog/hugo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","summary":"​ 首先安装hugo框架 详见Content Organization - Hugo中文文档 (gohugo.org) ​ 安装好hugo后你可以选择按照hugo的官方文档自己DIY网站的制作也可以再网上寻找别人已经制作好的hugo主题 笔者用的是第二种方法来构建自己的博客 主题链接为：[https://github.com/xyming10","title":"Hugo个人博客的搭建"},{"content":"关于我\n英文名: zah 职业: 学生 运动: 跑步、游戏 ","permalink":"https://pose1donz.github.io/about/","summary":"关于我 英文名: zah 职业: 学生 运动: 跑步、游戏","title":"🙋🏻‍♂️关于"},{"content":"","permalink":"https://pose1donz.github.io/posts/blog/blog/","summary":"","title":"Blog"},{"content":"","permalink":"https://pose1donz.github.io/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://pose1donz.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"","permalink":"https://pose1donz.github.io/posts/tech/tech/","summary":"","title":"Tech"},{"content":"\rPose1donz\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Pose1donz\u0026rsquo;s Blog 网址： https://pose1donz.github.io/ 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://pose1donz.github.io/links/","summary":"Pose1donz\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Pose1donz\u0026rsquo;s Blog 网址： https://pose1donz.github.io/ 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内","title":"🤝友链"},{"content":"holly\n","permalink":"https://pose1donz.github.io/posts/tech/text/","summary":"holly","title":"Text"}]